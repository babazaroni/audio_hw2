

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>USB Audio Applications &mdash; USB Audio Design Guide v documentation</title>

    <link rel="stylesheet" href=".static/pygments.css" type="text/css" />
    <link rel="stylesheet" href=".static/globals.css"  type="text/css" />
    <link rel="stylesheet" href=".static/ui.css" type="text/css" />
    <link rel="stylesheet" href=".static/app.css"  type="text/css" />
    <link rel="stylesheet" href=".static/mobile.css"  type="text/css" />
    <link rel="stylesheet" href=".static/xde.css"
    type="text/css" /><script type="text/javascript" src=".static/scripts.js"></script>
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src=".static/jquery.js"></script>
    <script type="text/javascript" src=".static/underscore.js"></script>
    <script type="text/javascript" src=".static/doctools.js"></script>
    <link rel="top" title="USB Audio Design Guide v documentation" href="index.html" />
    <link rel="next" title="USB Audio 2.0 Reference Design (L-Series) Application" href="page5.html#document-sw_l1_audio" />
    <link rel="prev" title="Adding Custom Code" href="page4.html#document-prog_modification" /> 
  </head>
  <body class="xde indented-content" onload="prepareContents();">  
          <div id="body">
             <div id="content">
             <h1>USB Audio Applications</h1>

             <div class='columns'>
            
  <p>In addition to the overall framework, reference design applications are provided. These
applications provide qualified configurations of the framework which support and are validated on
accompanying hardware.  This section looks at how the various applictions customise and extend the
framework.</p>
<span id="document-sw_l1_audio"></span><h2 class="topic" id="usb-audio-2-0-reference-design-l-series-application"><span id="usb-audio-sec-l1-audio-sw"></span>USB Audio 2.0 Reference Design (L-Series) Application</h2>
<div><p>The USB Audio 2.0 Reference Design is an application of the USB audio framework specifically
for the hardware described in <a class="reference" href="page1.html#usb-audio-sec-l1-audio-hw"><span>USB Audio 2.0 Reference Design</span></a> and is implemented
on the L-Series single tile device (500MIPS). The code can be found in <cite>app_usb_aud_l2</cite></p>
<p>The software design supports two channels of audio at sample frequencies up to 192kHz and uses
the following components:</p>
<blockquote>
<div><ul>
<li>XMOS USB Device Driver (XUD)</li>
<li>Endpoint 0</li>
<li>Endpoint buffer</li>
<li>Decoupler</li>
<li>Audio Driver</li>
<li>Device Firmware Upgrade (DFU)</li>
<li>S/PDIF Transmitter <em>or</em> MIDI</li>
</ul>
</div></blockquote>
<p>The diagrams <a class="reference" href="page5.html#usb-audio-l1-threads-spdif"><span>Single Tile L-Series Software Core Diagram (with S/PDIF TX)</span></a> and <a class="reference" href="page5.html#usb-audio-l1-threads-midi"><span>Single Tile L-Series Software Core Diagram (with MIDI I/O)</span></a> show the
software layout of the code running on the XS1-L chip. Each unit runs in a single core concurrently
with the others units. The lines show the communication between each functional unit. Due to the MIPS
requirement of the USB driver (see <a class="reference" href="page2.html#usb-audio-sec-resource-usage"><span>Resource Usage</span></a>), only six cores can be
run on the single tile L-Series device so only one of S/PDIF transmit or MIDI can be supported.</p>
<div class="figure" id="usb-audio-l1-threads-spdif">
<div class="caption"><span>Single Tile L-Series Software Core Diagram (with S/PDIF TX)</span></div>
<img alt="_images/threads-spdif-crop.png" src="_images/threads-spdif-crop.png" style="width: 100%;" />
</div>
<div class="figure" id="usb-audio-l1-threads-midi">
<div class="caption"><span>Single Tile L-Series Software Core Diagram (with MIDI I/O)</span></div>
<img alt="_images/threads-midi-crop.png" src="_images/threads-midi-crop.png" style="width: 100%;" />
</div>
<h3 id="port-32a">Port 32A</h3>
<div><p>Port 32A on the XS1-L device is a 32-bit wide port that has several separate signal bit signal
connected to it, accessed by multiple cores.  To this end, any output to this port must be
<em>read-modify-write</em> i.e. to change a single bit of the port, the software reads the current value
being driven across 32 bits, flips a bit and then outputs the modified value.</p>
<p>This method of port usage (i.e. sharing a port between cores) is outside the standard XC usage model
so is implemented using inline assembly as required.  The <tt class="docutils literal"><span class="pre">peek</span></tt> instruction is used to get the
current output value on the port:</p>
<pre class="snip-multi-inline">
/* Peek at current port value using port 32A resource ID */
asm("peek %0, res[%1]":=r"(x):"r"(XS1_PORT_32A));
</pre>
<p>The required output value is then assembled using the relevant bit-wise operation(s) before the
<tt class="docutils literal"><span class="pre">out</span></tt> instruction is used directly to output data to the port:</p>
<pre class="snip-multi-inline">
/* Output to port */
asm("out res[%0], %1"::"r"(XS1_PORT_32A),"r"(x));
</pre>
<p>The table <a class="reference" href="page5.html#usb-audio-port32a-signals"><span>Port 32A Signals</span></a> shows the signals connected to port 32A on the USB Audio
Class 2.0 reference design board.  Note, they are all <em>outputs</em> from the XS1-L device.</p>
<div class="figure"><div class="caption"><span>Port 32A Signals</span></div><table border="1" class="docutils" id="usb-audio-port32a-signals">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head"><p>Pin</p>
</th>
<th class="head"><p>Port</p>
</th>
<th class="head"><p>Signal</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><p>XD49</p>
</td>
<td><p>P32A0</p>
</td>
<td><p>USB_PHY_RST_N</p>
</td>
</tr>
<tr><td><p>XD50</p>
</td>
<td><p>P32A1</p>
</td>
<td><p>CODEC_RST_N</p>
</td>
</tr>
<tr><td><p>XD51</p>
</td>
<td><p>P32A2</p>
</td>
<td><p>MCLK_SEL</p>
</td>
</tr>
<tr><td><p>XD52</p>
</td>
<td><p>P32A3</p>
</td>
<td><p>LED_A</p>
</td>
</tr>
<tr><td><p>XD53</p>
</td>
<td><p>P32A4</p>
</td>
<td><p>LED_B</p>
</td>
</tr>
</tbody>
</table>
</div></div><h3 id="clocking">Clocking</h3>
<div><p>The board has two on-board oscillators for master clock generation. These produce 11.2896MHz for sample
rates 44.1, 88.2, 176.4KHz etc and 24.567MHz for sample rates 48, 96, 192kHz etc.</p>
<p>The required master clock is selected from one of these using an external mux circuit via port <em>P32A[2]</em>
(pin 2 of port 32A). Setting <em>P32A[2]</em> high selects 11.2896MHz, low selects 24.576MHz.</p>
<div class="figure">
<div class="caption"><span>Audio Clock Connections</span></div>
<img alt="_images/clocks.png" src="_images/clocks.png" />
</div>
<p>The reference design board uses a 24 bit, 192kHz stereo audio CODEC (Cirrus Logic CS4270).</p>
<p>The CODEC is configured to operate in <em>stand-alone mode</em> meaning that no serial configuration interface
is required.  The digital audio interface is set to I2S mode with all clocks being inputs (i.e. slave
mode).</p>
<p>The CODEC has three internal modes depending on the sampling rate used. These change the oversampling
ratio used internally in the CODEC. The three modes are shown below:</p>
<div class="figure"><div class="caption"><span>CODEC Modes</span></div><table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="45%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head"><p>CODEC mode</p>
</th>
<th class="head"><p>CODEC sample rate range (kHz)</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><p>Single-Speed</p>
</td>
<td><p>4-54</p>
</td>
</tr>
<tr><td><p>Double-Speed</p>
</td>
<td><p>50-108</p>
</td>
</tr>
<tr><td><p>Quad-Speed</p>
</td>
<td><p>100-216</p>
</td>
</tr>
</tbody>
</table>
</div><p>In stand-alone mode, the CODEC automatically determines which mode to operate in based on input
clock rates.</p>
<p>The internal master clock dividers are set using the MDIV pins.  MDIV is tied low
and MDIV2 is connected to bit 2 of port 32A (as well as to the master clock
select).
With MDIV2 low, the master clock must be 256Fs in single-speed mode, 128Fs in
double-speed mode and 64Fs in quad-speed mode. This allows an 11.2896MHz master
clock to be used for sample rates of 44.1, 88.2 and 176.4kHz.</p>
<p>With MDIV2 high, the master clock must be 512Fs in single-speed mode, 256Fs in
double-speed mode and 128Fs in quad-speed mode. This allows a 24.576MHz master
clock to be used for sample rates of 48, 96 and 192kHz.</p>
<p>When changing sample frequency, the
<tt class="xref c c-func docutils literal"><span class="pre">CodecConfig()</span></tt> function first puts the CODEC into reset by
setting <em>P32A[1]</em> low. It selects the required master clock/CODEC dividers and
keeps the CODEC in reset for 1ms to allow the clocks to stabilize.
The CODEC is brought out of reset by setting <em>P32A[1]</em> back high.</p>
</div><h3 id="hid">HID</h3>
<div><p>The reference design implements basic HID controls.  The call to <tt class="docutils literal"><span class="pre">vendor_ReadHidButtons()</span></tt> simply
reads from buttons A and B and returns their state in the relevant bits depending on the desired
functionality (play/pause/skip etc).  Note the buttons are active low, the HID controls active high.
The buttons are therefore read and then inverted.</p>
<pre>
/* Write HID Report Data into hidData array
 *
 * Bits are as follows:
 * 0: Play/Pause
 * 1: Scan Next Track
 * 2: Scan Prev Track
 * 3: Volume Up
 * 4: Volime Down
 * 5: Mute
 */
void UserReadHIDButtons(unsigned char hidData[])
{
#ifndef MIDI
    unsigned a, b;

    p_but_a :&gt; a;
    p_but_b :&gt; b;

    a = (~a) & 1;
    b = (~b) & 1;

    /* Assign buttons A and B to Vol Up/Down */
    hidData[0] = (a &lt;&lt; 3) | (b &lt;&lt; 4);
#endif
}

</pre>
<p>In the example above the buttons are assigned to volume up/down.</p>
</div><h3 id="validated-build-options">Validated Build Options</h3>
<div><p>The reference design can be built in several ways by changing the
build options.  These are described in <a class="reference" href="#usb-audio-sec-custom-defines-api"><span>Custom Defines</span></a>.</p>
<p>The design has only been fully validated against the build options as set in the
application as distributed.  See <a class="reference" href="page4.html#usb-audio-sec-valbuild"><span>Configuration Naming Scheme</span></a> for details and binary naming.</p>
<p>In practise, due to the similarities between the U-Series and L-Series feature set, it is fully expected that all listed U-Series
configurations will operate as expected on the L-Series and vice versa.</p>
<h4 id="configuration-2ioxs">Configuration 2ioxs</h4>
<div><p>This configuration runs in high-speed Audio Class 2.0 mode, has the mixer disabled, supports 2 channels in, 2
channels out and supports sample rates up to 192kHz and S/PDIF transmit.</p>
</div><h4 id="configuration-2iomx">Configuration 2iomx</h4>
<div><p>This configuration disables S/PDIF and enables MIDI.</p>
<p>This configuration can be achieved by in the Makefile by defining <tt class="docutils literal"><span class="pre">SPDIF</span></tt> as zero:</p>
<pre class="snip-single-inline">
-DSPDIF=0
</pre>
<p>and <tt class="docutils literal"><span class="pre">MIDI</span></tt> as 1:</p>
<pre class="snip-single-inline">
-DMIDI=1
</pre>
</div><h4 id="configuration-1ioxs">Configuration 1ioxs</h4>
<div><p>This configuration is similar to the first configuration apart from it runs in Audio 1.0 over full-speed USB.</p>
<p>This is achieved in the Makefile by:</p>
<pre class="snip-single-inline">
-DAUDIO_CLASS=1
</pre>
</div></div></div><span id="document-sw_su1_audio"></span><h2 class="topic" id="the-usb-audio-2-0-dj-kit-u-series"><span id="usb-audio-sec-su1-audio-sw"></span>The USB Audio 2.0 DJ Kit (U-Series)</h2>
<div><p>The USB Audio 2.0 Reference Design is an application of the USB audio framework specifically for the
hardware described in <a class="reference" href="page1.html#usb-audio-sec-su1-audio-hw"><span>USB Audio 2.0 DJ Kit</span></a> and is implemented on the U-Series single
tile device (500MIPS). The software design supports four channels of audio at sample frequencies up
to 192kHz and uses the following components:</p>
<blockquote>
<div><ul>
<li>XMOS USB Device Driver (XUD)</li>
<li>Endpoint 0</li>
<li>Endpoint buffer</li>
<li>Decoupler</li>
<li>Audio Driver</li>
<li>Device Firmware Upgrade (DFU)</li>
<li>S/PDIF Transmitter <em>or</em> MIDI</li>
</ul>
</div></blockquote>
<p>The software layout is the identical to the single tile L-Series Reference Design and therefore the
diagrams <a class="reference" href="page5.html#usb-audio-l1-threads-spdif"><span>Single Tile L-Series Software Core Diagram (with S/PDIF TX)</span></a> and <a class="reference" href="page5.html#usb-audio-l1-threads-midi"><span>Single Tile L-Series Software Core Diagram (with MIDI I/O)</span></a> show the software
layout of the code running on the XS1-U chip.</p>
<p>As with the L-Series, each unit runs in a single core concurrently with the others units.</p>
<p>Due to the MIPS requirement of the USB driver (see <a class="reference" href="page2.html#usb-audio-sec-resource-usage"><span>Resource Usage</span></a>), only six
cores can be run on the single tile L-Series device so only one of S/PDIF transmit or MIDI can be
supported.</p>
<h3 id="clocking-and-clock-selection">Clocking and Clock Selection</h3>
<div><p>The actual hardware involved in the clock generation is somewhat different to the single tile
L-Series board.  Instead of two separate oscillators and switching logic a single oscillator
with a Phaselink PLL is used to generate fixed 24.576MHz and 22.5792MHz master-clocks.</p>
<p>This makes no change for the selection of master-clock in terms of software interaction: A single
pin is (bit 1 of port 4C) is still used to select between the two master-clock frequencies.</p>
<p>The advantages of this system are fewer components and a smaller board area.</p>
<p>When changing sample frequency, the <tt class="xref c c-func docutils literal"><span class="pre">CodecConfig()</span></tt> function first puts the CODEC into reset
by setting <em>P4C[2]</em> low. It selects the required master clock  and keeps the CODEC in reset for 1ms
to allow the clocks to stabilize.
The CODEC is brought out of reset by setting <em>P4C[2]</em> back high.</p>
</div><h3 id="codec-configuration">CODEC Configuration</h3>
<div><p>The board is equipped with two stereo audio CODECs (Cirrus Logic CS4270) giving 4 channels of input
and 4 channels of output. Configuration of these CODECs takes place using I2C, with both sharing
the same I2C bus. The design uses the open source I2C component <a class="reference" href="http://www.github.com/xcore/sc_i2c"><span>sc_i2c</span></a></p>
</div><h3 id="u-series-adc">U-Series ADC</h3>
<div><p>The codebase includes code exampling how the ADC built into the U-Series device can be used.
Once setup a pin is used to cause the ADC to sample, this sample is then sent via a channel to the
xCORE device.</p>
<p>On the DJ kit the ADC is clocked via the same pin as the I2S LR clock.  Since this means that a ADC
sample is received every audio sample the ADC is setup and it&#8217;s data received in the audio driver
core (<tt class="docutils literal"><span class="pre">audio.xc</span></tt>).</p>
<p>The code simply writes the ADC value to the global variable <tt class="docutils literal"><span class="pre">g_adcVal</span></tt> for use elsewhere in the
program as required.  The ADC code is enabled by defining <tt class="docutils literal"><span class="pre">SU1_ADC_ENABLE</span></tt> as <tt class="docutils literal"><span class="pre">1</span></tt>.</p>
</div><h3 id="hid-example">HID Example</h3>
<div><p>The codebase includes an example of a HID volume control implementation based on ADC data.  This
code should be considered an example only since an absolute ADC input does not serve as an ideal
input to a relative HID volume control.  Buttons (such as that on the single tile L-Series board)
or a Rotary Encoder would be a more fitting choice of input component.</p>
<p>This code is enabled if <tt class="docutils literal"><span class="pre">HID_CONTROLS</span></tt>, <tt class="docutils literal"><span class="pre">SU1_ADC_ENABLE</span></tt> and <tt class="docutils literal"><span class="pre">ADC_VOL_CONTROL</span></tt> are all
defined as <tt class="docutils literal"><span class="pre">1</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">Vendor_ReadHIDButtons()</span></tt> function simply looks at the value from the ADC, if is near the
maximum value it reports a volume up, near the minimum value a volume down is reported.  If the
ADC value is mid-range no event is reported.  The code is shown below:</p>
<pre>

void Vendor_ReadHIDButtons(unsigned char hidData[])
{
    unsigned adcVal;
    int diff;

    hidData[0] = 0;

#if defined(ADC_VOL_CONTROL) && (ADC_VOL_CONTROL == 1)
    adcVal = g_adcVal &gt;&gt; 20;

    if(adcVal &lt; (ADC_MIN + THRESH))
    {
        /* Volume down */
        hidData[0] = 0x10;
    }
    else if (adcVal &gt; (ADC_MAX - THRESH))
    {
        /* Volume up */
        hidData[0] = 0x08;
    }

</pre>
</div><h3 id="validated-build-options">Validated Build Options</h3>
<div><p>The reference design can be built in several ways by changing the
build options.  These are described in <a class="reference" href="#usb-audio-sec-custom-defines-api"><span>Custom Defines</span></a>.</p>
<p>The design has only been fully validated against the build options as set in the
application as distributed.  See <a class="reference" href="page4.html#usb-audio-sec-valbuild"><span>Configuration Naming Scheme</span></a> for details and binary naming scheme.</p>
<p>These fully validated build configurations are listed below.
In practise, due to the similarities between the U-Series and L-Series feature set, it is fully
expected that all listed U-Series configurations will operate as expected on the L-Series and vice versa.</p>
<h4 id="configuration-2ioxs">Configuration 2ioxs</h4>
<div><p>This configuration runs in high-speed Audio Class 2.0 mode, has the mixer disabled, supports 2 channels in, 2
channels out, supports sample rates up to 192kHz and S/PDIF transmit.</p>
</div><h4 id="configuration-2iomx">Configuration 2iomx</h4>
<div><p>This configuration disables S/PDIF and enables MIDI.</p>
<p>This configuration can be achieved by in the Makefile by defining <tt class="docutils literal"><span class="pre">SPDIF</span></tt> as zero:</p>
<pre class="snip-single-inline">
-DSPDIF=0
</pre>
<p>and <tt class="docutils literal"><span class="pre">MIDI</span></tt> as 1:</p>
<pre class="snip-single-inline">
-DMIDI=1
</pre>
</div><h4 id="configuration-2ixxx">Configuration 2ixxx</h4>
<div><p>This configuration is input only (<tt class="docutils literal"><span class="pre">NUM_USB_CHAN_OUT</span></tt> set to zero).  I.e. a microphone application or similar.</p>
</div><h4 id="configuration-1ioxs">Configuration 1ioxs</h4>
<div><p>This configuration is similar to the first configuration apart from it runs in Audio 1.0 over full-speed USB.</p>
<p>This is achieved in the Makefile by:</p>
<pre class="snip-single-inline">
-DAUDIO_CLASS=1
</pre>
</div><h4 id="configuration-1xoxs">Configuration 1xoxs</h4>
<div><p>This configuration is similar to the configuration above in that it runs in Audio 1.0 over full-speed USB.
However, the it is output only (i.e. the input path is disabled with <tt class="docutils literal"><span class="pre">-DNUM_USB_CHAN_IN=0</span></tt></p>
</div></div></div><span id="document-sw_l2_audio"></span><h2 class="topic" id="the-usb-audio-2-0-multichannel-reference-design-l-series-software"><span id="usb-audio-sec-l2-audio-sw"></span>The USB Audio 2.0  Multichannel Reference Design (L-Series) Software</h2>
<div><p>The USB Audio 2.0 Multichannel Reference Design
is an application of the USB audio
framework specifically for the hardware described in
<a class="reference" href="page1.html#usb-audio-sec-l1-audio-hw"><span>USB Audio 2.0 Reference Design</span></a> and is implemented on an L-Series dual tile
device (1000MIPS).
The software design supports up to 16 channels of
audio in and 10 channels of audio out and supports sample frequencies up to 192 kHz and uses the following components:</p>
<blockquote>
<div><ul>
<li>XMOS USB Device Driver (XUD)</li>
<li>Endpoint 0</li>
<li>Endpoint buffer</li>
<li>Decoupler</li>
<li>Audio Driver</li>
<li>Device Firmware Upgrade (DFU)</li>
<li>Mixer</li>
<li>S/PDIF Transmitter</li>
<li>S/PDIF Receiver</li>
<li>ADAT Receiver</li>
<li>Clockgen</li>
<li>MIDI</li>
</ul>
</div></blockquote>
<p>The figure below  shows the software layout of the USB
Audio 2.0 Multichannel Reference Design.</p>
<div align="center" class="figure" id="usb-audio-l2-threads">
<div class="caption"><span>Dual Tile L-Series Reference Design Core Layout</span></div>
<img alt="_images/threads-l2-crop.png" src="_images/threads-l2-crop.png" style="width: 90%;" />
</div>
<h3 id="clocking">Clocking</h3>
<div><p>For complete clocking flexibility the dual tile L-Series reference design drives a reference clock to an external fractional-n clock multiplier IC (Cirrus
Logic CS2300).  This in turn generates the master clock used over the
design.  This is described in <a class="reference" href="page2.html#usb-audio-sec-clock-recovery"><span>External Clock Recovery (ClockGen)</span></a>.</p>
</div><h3 id="validated-build-options">Validated Build Options</h3>
<div><p>The reference design can be built in several ways by changing the
option described in <a class="reference" href="#usb-audio-sec-custom-defines-api"><span>Custom Defines</span></a>. However, the design
has only been validated against the build options as set in the
application as distributed with the following four variations.</p>
<h4 id="configuration-1">Configuration 1</h4>
<div><p>All the #defines are set as per the distributed
application. It has the mixer enabled, supports 16 channels in, 10
channels out and supports sample rates up to 96kHz.</p>
</div><h4 id="configuration-2">Configuration 2</h4>
<div><p>The same as Configuration 1 but with the CODEC
set as I2S master (and the XCORE Tile as slave).</p>
<p>This configuration can be achieved by commenting out the following
line in <tt class="docutils literal"><span class="pre">customdefines.h</span></tt>:</p>
<pre class="snip-single-inline">
//#define CODEC_SLAVE        1
</pre>
</div><h4 id="configuration-3">Configuration 3</h4>
<div><p>This configuration supports sample rates up to 192kHz but only
supports 10 channels in and out. It also disables
ADAT receive and the mixer. It can be achieved by commenting out
the following lines in <tt class="docutils literal"><span class="pre">customdefines.h</span></tt>:</p>
<pre class="snip-multi-inline">
//#define MIXER
//#define ADAT_RX            1
</pre>
<p>and changing the following defines to:</p>
<pre class="snip-multi-inline">
#define NUM_USB_CHAN_IN  (10)
#define I2S_CHANS_ADC    (6)
#define SPDIF_RX_INDEX   (8)
</pre>
</div><h4 id="configuration-4">Configuration 4</h4>
<div><p>The same as Configuration 3 but with the CODEC set as I2S master.
This configuration can be made by making the changes for Configuration
3 and commenting out the following line in <tt class="docutils literal"><span class="pre">customdefines.h</span></tt>:</p>
<pre class="snip-single-inline">
//#define CODEC_SLAVE        1
</pre>
</div></div></div><span id="document-sw_u8_audio"></span><h2 class="topic" id="the-multi-function-audio-kit-u-series"><span id="usb-audio-sec-u8-audio-sw"></span>The Multi-function Audio Kit (U-Series)</h2>
<div><p>Provided is an application of the USB audio framework specifically for the hardware described in <a class="reference" href="page1.html#usb-audio-sec-u8-audio-hw"><span>USB Multi-function Audio Kit</span></a> and is implemented on the U-Series single tile device (500MIPS).  The application assumes a standard USB B socket (i.e. USB device) is attached as the USB connectivity method.</p>
<p>The software design supports 2 channels channels of
audio at sample frequencies up to 192kHz and uses the following components:</p>
<blockquote>
<div><ul>
<li>XMOS USB Device Driver (XUD)</li>
<li>Endpoint 0</li>
<li>Endpoint buffer</li>
<li>Decoupler</li>
<li>Audio Driver</li>
<li>Device Firmware Upgrade (DFU)</li>
<li>S/PDIF Transmitter <em>or</em> MIDI</li>
</ul>
</div></blockquote>
<p>The software layout is the identical to the single tile L-Series Reference Design and therefore the diagrams <a class="reference" href="page5.html#usb-audio-l1-threads-spdif"><span>Single Tile L-Series Software Core Diagram (with S/PDIF TX)</span></a> and <a class="reference" href="page5.html#usb-audio-l1-threads-midi"><span>Single Tile L-Series Software Core Diagram (with MIDI I/O)</span></a> show the software layout of the code running on the XS1-U chip.</p>
<p>As with the L-Series, each unit runs in a single core concurrently with the others units. The lines show the
communication between each functional unit.</p>
<p>Due to the MIPS requirement of the USB driver
(see <a class="reference" href="page2.html#usb-audio-sec-resource-usage"><span>Resource Usage</span></a>), only six cores can be
run on the single tile L-Series device so only one of S/PDIF transmit or MIDI
can be supported.</p>
<h3 id="clocking-and-clock-selection">Clocking and Clock Selection</h3>
<div><p>A single oscillator with a Phaselink PLL is used to generate fixed 24.576MHz and 22.5792MHz master-clocks.</p>
<p>This makes no change for the selection of master-clock in terms of software interaction: A single pin is (bit 1 of port 32A) is used to select between the two master-clock frequencies.</p>
<p>When changing sample frequency, the <a class="reference" href="page3.html#AudioHwConfig" title="AudioHwConfig"><span>AudioHwConfig()</span></a> function first puts the both the DAC and ADC into reset by
setting <em>P4C[0]</em> and <em>P4C[1]</em> low. It selects the required master clock and keeps both the DAC and ADC in reset for 1ms to allow the
clocks to stabilize.
The DAC and ADC are brought out of reset by setting <em>P4C[0]</em> and <em>P4C[1]</em> back high.</p>
</div><h3 id="dac-and-adc-configuration">DAC and ADC Configuration</h3>
<div><p>The board is equipped with a single stereo audio DAC (Cirrus Logic CS4392) and a single stereo ADC (Cirrus Logic 5340) giving 2 channels of input and 2 channels of output.</p>
<p>Configuration of the DAC takes place using I2C.  The design uses the open source I2C component <a class="reference" href="http://www.github.com/xcore/sc_i2c"><span>sc_i2c</span></a> No configuration of the ADC is required in software, it is set into slave mode via its configuration pins on the board.</p>
</div><h3 id="u-series-adc">U-Series ADC</h3>
<div><p>The codebase includes code exampling how the ADC built into the U-Series device can be used.  Once setup a pin is used to cause the ADC to sample, this sample is then sent via a channel to the xCORE device.</p>
<p>On the multi-function audio board the ADC is clocked via the same pin as the I2S LR clock.  Since this means that a ADC sample is received every audio sample the ADC is setup and it&#8217;s data received in the audio driver core (<tt class="docutils literal"><span class="pre">audio.xc</span></tt>).</p>
<p>The ADC inputs for the U8 device are simply pinned out to test point headers.  As such there is no example functionality attached to the ADC data.</p>
</div><h3 id="hid-example">HID Example</h3>
<div><p>The codebase includes an example of a HID controls implementation using the two buttons and switch on the multi-function audio board.</p>
<p>This example code is enabled if <tt class="docutils literal"><span class="pre">HID_CONTROLS</span></tt> are all defined as <tt class="docutils literal"><span class="pre">1</span></tt>.  When this define is enabled a call to the function <tt class="docutils literal"><span class="pre">Vendor_ReadHIDButtons()</span></tt> is enabled and must be implemented. Failing to do so will result in a build error.</p>
<p>The example <tt class="docutils literal"><span class="pre">Vendor_ReadHIDButtons()</span></tt> firstly reads the state of the buttons and switch.  These inputs are all connected to the same 4-bit port.  Since the buttons are active low and the HID report is active high the value read is inverted.  Some bitwise operations are then used to exact the individual states of the buttons and switch.</p>
<p>If the switch input is low (i.e. high when inverted) then the button states are shifted up into the position required perform volume up and down and written into the <em>hidData[]</em> array:</p>
<pre>
        hidData[0] = (a &lt;&lt; 4) | (b &lt;&lt; 3);

</pre>
<p>If the switch input is high (i.e. low when inverted) then the buttons states are used to either indicate play/pause or next/previous.  Based on counter and a small state-machine a single click on either button provides a play/pause command.  A double tap on button A or B provides a previous or next command respectively.</p>
<p>The full code listing is shown below:</p>
<pre>

void UserReadHIDButtons(unsigned char hidData[])
{
    /* Variables for buttons a & b and switch sw */
    unsigned a, b, sw, tmp;

    p_sw :&gt; tmp;

    /* Buttons are active low */
    tmp = ~tmp;

    a = (tmp & (P_GPI_BUTA_MASK))&gt;&gt;P_GPI_BUTA_SHIFT;
    b = (tmp & (P_GPI_BUTB_MASK))&gt;&gt;P_GPI_BUTB_SHIFT;
    sw = (tmp & (P_GPI_SW1_MASK))&gt;&gt;P_GPI_SW1_SHIFT;

    if(sw)
    {
        /* Assign buttons A and B to Vol Up/Down */
        hidData[0] = (a &lt;&lt; 4) | (b &lt;&lt; 3);
    }
    else
    {
        /* Assign buttons A and B to play for single tap, next/prev for double tap */
        if(b)
        {
            multicontrol_count++;
        	wait_counter = 0;
            lastA = 0;
    	}
        else if(a)
        {
            multicontrol_count++;
        	wait_counter = 0;
            lastA = 1;
        }
        else
        {
    	    if(multicontrol_count &gt; THRESH)
    	    {
    	    	state++;
    	    }

    	    wait_counter++;

    	    if(wait_counter &gt; MULTIPRESS_WAIT)
            {
    		    if(state == STATE_PLAY)
                {
    			    hidData[0] = HID_CONTROL_PLAYPAUSE;
    		    }
    		    else if(state == STATE_NEXTPREV)
                {
                    if(lastA)
    			        hidData[0] = HID_CONTROL_PREV;
    		        else
    			        hidData[0] = HID_CONTROL_NEXT;
                }
    		    state = STATE_IDLE;
    	    }
    	    multicontrol_count = 0;
        }
    }
}


</pre>
</div><h3 id="validated-build-options">Validated Build Options</h3>
<div><p>The reference design can be built in several ways by changing the
build options.  These are described in <a class="reference" href="page3.html#sec-custom-defines-api"><span>Configuration Defines</span></a>.</p>
<p>The design has only been fully validated against the build options as set in the
application as distributed.  See <a class="reference" href="page4.html#usb-audio-sec-valbuild"><span>Configuration Naming Scheme</span></a> for details and binary naming scheme.</p>
<p>These fully validated build configurations are listed below.
In practise, due to the similarities between the U-Series and L-Series feature set, it is fully expected that all listed U-Series
configurations will operate as expected on the L-Series and vice versa.</p>
<h4 id="configuration-2ioxs">Configuration 2ioxs</h4>
<div><p>This configuration runs in high-speed Audio Class 2.0 mode, has the mixer disabled, supports 2 channels in, 2
channels out, supports sample rates up to 192kHz and S/PDIF transmit.</p>
</div><h4 id="configuration-2iomx">Configuration 2iomx</h4>
<div><p>This configuration disables S/PDIF and enables MIDI.</p>
<p>This configuration can be achieved by in the Makefile by defining <tt class="docutils literal"><span class="pre">SPDIF</span></tt> as zero:</p>
<pre class="snip-single-inline">
-DSPDIF=0
</pre>
<p>and <tt class="docutils literal"><span class="pre">MIDI</span></tt> as 1:</p>
<pre class="snip-single-inline">
-DMIDI=1
</pre>
</div><h4 id="configuration-2ixxx">Configuration 2ixxx</h4>
<div><p>This configuration is input only (<tt class="docutils literal"><span class="pre">NUM_USB_CHAN_OUT</span></tt> set to zero).  I.e. a microphone application or similar.</p>
</div><h4 id="configuration-1ioxs">Configuration 1ioxs</h4>
<div><p>This configuration is similar to the first configuration apart from it runs in Audio 1.0 over full-speed USB.</p>
<p>This is achieved in the Makefile by:</p>
<pre class="snip-single-inline">
-DAUDIO_CLASS=1
</pre>
</div><h4 id="configuration-1xoxs">Configuration 1xoxs</h4>
<div><p>This configuration is similar to the configuration above in that it runs in Audio 1.0 over full-speed USB.  However, the it is output only (i.e. the input path is disabled with <tt class="docutils literal"><span class="pre">-DNUM_USB_CHAN_IN=0</span></tt></p>
</div></div></div><span id="document-sw_u16_audio8"></span><h2 class="topic" id="the-u-series-multi-channel-usb-audio-kit"><span id="usb-audio-sec-u16-audio8-sw"></span>The U-Series Multi-Channel USB Audio Kit</h2>
<div><p>An application of the USB audio framework is provideed specifically for the hardware described in
<a class="reference" href="page1.html#usb-audio-sec-hw-u16-audio8"><span>U16 Mult-Channel USB Audio Kit</span></a> and is implemented on the U-Series dual tile device (1000MIPS).
The application assumes a standard USB B socket (i.e. USB device) is provided as the USB connectivity
method.  The related code can be found in <cite>app_usb_aud_u16_audio8</cite>.</p>
<p>The design supports 10 channels channels of audio input and output at sample frequencies up to
192kHz and uses the following components:</p>
<blockquote>
<div><ul>
<li>XMOS USB Device Driver (XUD)</li>
<li>Endpoint 0</li>
<li>Endpoint buffer</li>
<li>Decoupler</li>
<li>Audio Driver</li>
<li>Device Firmware Upgrade (DFU)</li>
<li>S/PDIF Transmitter</li>
<li>MIDI</li>
</ul>
</div></blockquote>
<p>The software layout is the identical to the single tile L-Series Multi-channel Reference Design
and therefore the diagram <a class="reference" href="page5.html#usb-audio-l2-threads"><span>Dual Tile L-Series Reference Design Core Layout</span></a> shows the software arrangement of the code
running on the XS1-U chip.</p>
<p>As with the L-Series, each unit runs in a single core concurrently with the others units. The
lines show the communication between each functional unit.</p>
<h3 id="clocking-and-clock-selection">Clocking and Clock Selection</h3>
<div><p>The XA-SK-AUDIO8 double-slot slice includes two options for master clock generation:</p>
<blockquote>
<div><ul>
<li>A single oscillator with a Phaselink PLL to generate fixed 24.576MHz and 22.5792MHz
master-clocks</li>
<li>A Cirrus Logic CS2100 clock multiplier allowing the master clock to be generated from a
XCore derived reference.</li>
</ul>
</div></blockquote>
<p>The master clock source is controlled by a mux which, in turn, is controlled by bit 1 of <cite>PORT 4D</cite>:</p>
<div class="figure"><div class="caption"><span>Master Clock Source Selection</span></div><table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head"><p>Value</p>
</th>
<th class="head"><p>Source</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><p>0</p>
</td>
<td><p>Master clock is sourced from PhaseLink PLL</p>
</td>
</tr>
<tr><td><p>1</p>
</td>
<td><p>Master clock is source from Cirrus Clock Multiplier</p>
</td>
</tr>
</tbody>
</table>
</div><p>The current version of the supplied application only supports the use of the fixed master-clocks
from the PhaseLink part.</p>
<p>The clock-select from the phaselink part is controlled via bit 2 of <cite>PORT 4E</cite>:</p>
<div class="figure"><div class="caption"><span>Master Clock Frequency Select</span></div><table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head"><p>Value</p>
</th>
<th class="head"><p>Frequency</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><p>0</p>
</td>
<td><p>24.576MHz</p>
</td>
</tr>
<tr><td><p>1</p>
</td>
<td><p>22.579MHz</p>
</td>
</tr>
</tbody>
</table>
</div></div><h3 id="dac-and-adc-configuration">DAC and ADC Configuration</h3>
<div><p>The board is equipped with a single multi-channel audio DAC (Cirrus Logic CS4384) and a single
multi-channel ADC (Cirrus Logic CS5368) giving 8 channels of analogue output and 8 channels of
analogue input.</p>
<p>Configuration of both the DAC and ADC takes place using I2C.  The design uses the I2C component <a class="reference" href="http://www.github.com/xcore/sc_i2c"><span>sc_i2c</span></a>.</p>
<p>The reset lines of the DAC and ADC are connected to bits 0 and 1 of <cite>PORT 4E</cite> respectively.</p>
</div><h3 id="audiohwinit">AudioHwInit()</h3>
<div><p>The <a class="reference" href="page3.html#AudioHwInit" title="AudioHwInit"><span>AudioHwInit()</span></a> function is implemented to perform the following:</p>
<blockquote>
<div><ul>
<li>Initialise the I2C master software module</li>
<li>Puts the audio hardware into reset</li>
<li>Enables the power to the audio hardware</li>
<li>Select the PhaseLink PLL as the audio master clock source.</li>
</ul>
</div></blockquote>
</div><h3 id="audiohwconfig">AudioHwConfig()</h3>
<div><p>The <a class="reference" href="page3.html#AudioHwConfig" title="AudioHwConfig"><span>AudioHwConfig()</span></a> function is called on every sample frequency change.</p>
<p>The <a class="reference" href="page3.html#AudioHwConfig" title="AudioHwConfig"><span>AudioHwConfig()</span></a> function first puts the both the DAC and ADC into reset by
setting <em>P4E[0]</em> and <em>P4E[1]</em> low. It then selects the required master clock and keeps both the
DAC and ADC in reset for a period in order allow the clocks to stabilize.</p>
<p>The DAC and ADC are brought out of reset by setting <em>P4E[0]</em> and <em>P4E[1]</em> back high.</p>
<p>Various registers are then written to the ADC and DAC as required.</p>
</div><h3 id="validated-build-options">Validated Build Options</h3>
<div><p>The reference design can be built in several ways by changing the
build options.  These are described in <a class="reference" href="page3.html#sec-custom-defines-api"><span>Configuration Defines</span></a>.</p>
<p>The design has only been fully validated against the build options as set in the
application as distributed.  See <a class="reference" href="page4.html#usb-audio-sec-valbuild"><span>Configuration Naming Scheme</span></a> for details and binary naming scheme.</p>
<p>These fully validated build configurations are listed below.
In practise, due to the similarities between the U-Series and L-Series feature set, it is fully
expected that all listed U-Series configurations will operate as expected on the L-Series and vice versa.</p>
<h4 id="configuration-2ioxs">Configuration 2ioxs</h4>
<div><p>This configuration runs in high-speed Audio Class 2.0 mode, has the mixer core is enabled (for
volume processing only, supports 10 channels in, 10 channels out, supports sample rates up to
192kHz and S/PDIF transmit.</p>
</div></div></div>

             </div>
             </div>


          </div>

          <div>
             <!--seealsos-->
          </div><div id="local_seealso">
             <h1>See Also</h1>
             <ul class="iconmenu">
             <li><a href="page0.html">USB Audio Solution Overview</a></li>
             <li><a href="page1.html">USB Audio Hardware Platforms</a></li>
             <li><a href="page2.html">USB Audio Software Architecture</a></li>
             <li><a href="page6.html">Features & Options</a></li>
             <li><a href="page4.html">USB Audio Programming Guide</a></li>
             <li><a href="page3.html">USB Audio API Reference</a></li>
             <li><a href="page7.html">Frequently Asked Questions</a></li>
             </ul>
          </div>
    <div class="footer">
    </div>
  </body>
</html>